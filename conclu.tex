\chapter*{Conclusion}
\markboth{CONCLUSION}{}
\addcontentsline{toc}{chapter}{Conclusion}

This master thesis covered the study, the implementation and the comparison between the experimental and theoretical results of a \textit{Poisson solver}, i.e. an algorithm designed to solve Poisson's equation. This equation pervades across multiple domains in engineering : astrophysics, chemistry, mechanics, statistics and image processing are examples of areas where elliptic partial differential equations appear. Several numerical schemes also involve the resolution of Poisson's equation, such as different methods to solve Navier-Stokes equations for incompressible flows. That is why having a fast and robust \textit{Poisson solver} that can scale to trillions of unknowns and millions of CPU cores is a necessity. 

There exists a lot of algorithms that can be implemented into a \textit{Poisson solver}. We explained in the first chapter that, when the forcing term is a smooth function with very localized features (as it is often the case in practice), the high-order geometric multigrid method shows the best performances. In the present work, we chose to use low-order geometric multigrid method as a preconditioner along with an overlapping additive Schwarz preconditioner for the preconditioned conjugate gradients.  

The chosen algorithm for the discretization was the spectral element method on an adaptive mesh. This is a high-order method that allows us to meet high accuracy requirements. The fact that we are solving the problem on an adaptive mesh allowed us to capture the very local features of the forcing term while keeping the number of unknowns down since, in practice, large parts of the computational domain do not require high levels of refinement. The second chapter exposed the theoretical reasons behind the choices made and how to handle hanging nodes, whose presence comes from the adaptive refinement. 

The implementation of the algorithm resulted in a code written in plain C consisting of more than 8000 lines. It was not possible to present the entire structure of the program but the third chapter presents some important design features when implementing the algorithm. Especially, it was showed that the essential part of the design lies in the data structures used. The practical way to handle hanging nodes is also explained. In particular, the fact that the hanging nodes can only be found on the edges of the quadrants allows us to compute efficiently the relation between hanging and global nodes. 

In the fourth chapter, we put the chosen algorithm to the test. Several observations were made and can be summarized as follows : 

\begin{itemize}
\item The geometric multigrid method is very efficient and allows for h-independent convergence. For a large set of parameters, the number of iterations needed to reach the given tolerance did not depend on the number of quadrants in the mesh. The presence of hanging does not affect whatsoever the number of iterations. The method works both on meshes with regular quadrants and with distorted elements. 
\item Used on its own, the overlapping additive Schwarz preconditioner is not very efficient when the number of quadrant increases. Indeed, the number of iterations almost doubles when we divide the mesh size by two. This was expected in the absence of a coarse grid correction. On the other hand, when we increase the degree of the interpolation, the coarse preconditioner does the intended job and keeps the number of iterations down. We however still observe a small increase that is due to the fact that the size of the overlap decreases.
\item For the fine scale preconditioner, we computed an analytic solution based on the assumption that the quadrants were aligned with the axes. Having distorted elements in the mesh has an influence on the number of iterations but the gain of not solving exactly the problem on each subdomain is still huge compared to the time lost by the growth of the number of iterations of PCG.
\item The presence of hanging nodes has an influence of the fine preconditioner. It is less effective in non conforming meshes. That is because some cases are not treated when we compute the residual in the overlaps. 
\item Adding the coarse preconditioner to the fine one has a huge benefit. It allows to keep the number of iterations of PCG constant when we refine the grid. With the two scale preconditioner, we also have that the number of hanging nodes does not have an influence at all on the number of iterations. However, it has to be noted that we need fewer iterations when we do not have hanging nodes than when we do (even a few). 
\item If the accuracy requirements are low, it is quicker to use low order methods. This is because when we increase the degree of the interpolation, we also increase the number of iterations of PCG. As we increase the accuracy requirements, it becomes more and more important to use high-order methods. Indeed, for smooth functions, we need several order of magnitudes fewer degrees of freedom to reach a high accuracy with high-order method than with low-order ones. Therefore, the increase in the number of iterations of PCG is balanced by the fact that one iteration takes a lot less time to be performed. 
\end{itemize}

This thesis essentially presents a fast \textit{Poisson solver}. However, it could still be improved. First, we would like to be able to handle three dimensional problems. The second direct improvement would be to make the code parallel. Of course, the results presented here would not change (number of iterations, efficiency of the coarse and fine preconditioners,...) but it would be interesting to see if the algorithm developed in this thesis is also efficient when implemented on multiple cores. The parallelization of the matrix-vector products would be fairly straighforward, as would be the fine preconditioner since it is local-based. However, it would be more difficult for the geometric multigrid solver. Indeed, when we coarsen four quadrants into their parent to go up one level, we have no guarantee that the four children belong to the same processor. It is nonetheless feasible (for example in \cite{multi_impl}). Another improvement we can mention is to try and keep the overlap constant even when we increase the degree of the interpolation in order to improve the fine preconditioner. 



